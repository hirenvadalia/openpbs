/*
 * Copyright (C) 1994-2020 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * For a copy of the commercial license terms and conditions,
 * go to: (http://www.pbspro.com/UserArea/agreement.html)
 * or contact the Altair Legal Department.
 *
 * Altair’s dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of PBS Pro and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair’s trademarks, including but not limited to "PBS™",
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
 * trademark licensing policies.
 *
 */
#include <pbs_config.h>   /* the master config generated by configure */
#include <errno.h>
#include "pbs_ifl.h"
#include "libpbs.h"
#include "log.h"

#define FB_ATTROPL(var, B, attrs) \
do { \
	var = PBSE_FLATCC_ERROR; \
	if ((var = wire_encode_attropl(B, attrs)) == PBSE_FLATCC_ERROR) \
		return PBSE_FLATCC_ERROR; \
} while(0)

#define FB_ATTRL(var, B, attrs) \
do { \
	var = PBSE_FLATCC_ERROR; \
	if ((var = wire_encode_attrl(B, attrs)) == PBSE_FLATCC_ERROR) \
		return PBSE_FLATCC_ERROR; \
} while(0)

int
wire_encode_batch_start(flatcc_builder_t *B, int prot, char **msgid)
{
	flatcc_builder_init(B);

	if (prot == PROT_TPP) {
		if (is_compose_cmd(B, IS_CMD, msgid) != PBSE_NONE)
			return PBSE_FLATCC_ERROR;
		ns(Req_start(B));
	} else {
		ns(Req_start_as_root(B));
	}

}

ns(Header_ref_t)
wire_encode_hdr(flatcc_builder_t *B, int reqid, char *user, int prot, char **msgid)
{
	flatbuffers_string_ref_t usr = 0;

	ns(Header_start(B));
	ns(Header_protType_add(B, ns(ProtType_Batch)));
	ns(Header_version_add(B, PBS_BATCH_PROT_VER));
	ns(Header_reqId_add(B, reqid));
	FB_STR(usr, B, user);
	ns(Header_user_add(B, usr));

	return ns(Header_end(B));
}

static ns(Attribute_ref_t)
__wire_encode_attr(flatcc_builder_t *B, char *name, char *resc, char *value, int op)
{
	flatbuffers_string_ref_t s = 0;

	ns(Attribute_start(B));
	FB_STR(s, B, name);
	ns(Attribute_name_add(B, s));
	if (resc != NULL) {
		FB_STR(s, B, resc);
		ns(Attribute_resc_add(B, s));
	}
	FB_STR(s, B, value);
	ns(Attribute_value_add(B, s));
	ns(Attribute_op_add(B, op));

	return ns(Attribute_end(B));
}

static ns(Attribute_vec_t)
__wire_encode_attropl(flatcc_builder_t *B, struct attropl *pattropl, int use_op)
{
	struct attropl *ps = NULL;

	ns(Attribute_vec_start(B));
	for (ps = pattropl; ps != NULL; ps = ps->next) {
		ns(Attribute_vec_push(B, __wire_encode_attr(B, ps->name,
								ps->resource,
								ps->value,
								use_op ? (int) ps->op : SET)));
	}

	return ((ns(Attribute_vec_end(B))));
}

ns(Attribute_vec_t)
wire_encode_attropl(flatcc_builder_t *B, struct attropl *pattropl)
{
	return __wire_encode_attropl(B, pattropl, 1);
}

ns(Attribute_vec_t)
wire_encode_attrl(flatcc_builder_t *B, struct attrl *pattrl)
{
	return __wire_encode_attropl(B, (struct attropl *)pattrl, 0);
}

ns(Attribute_vec_t)
wire_encode_svrattrl(flatcc_builder_t *B, svrattrl *pattrl)
{
	svrattrl *ps = NULL;

	ns(Attribute_vec_start(B));
	for (ps = pattrl; ps != NULL; ps = (svrattrl *)GET_NEXT(ps->al_link)) {
		ns(Attribute_vec_push(B, __wire_encode_attr(B, ps->al_name,
								ps->al_rescln > 0 ? ps->al_resc : NULL,
								ps->al_value, ps->al_op)));
	}

	return ((ns(Attribute_vec_end(B))));
}


ns(Qjob_ref_t)
wire_encode_QueueJob(flatcc_builder_t *B, char *jobid, char *destin, struct attropl *aoplp)
{
	ns(Attribute_vec_ref_t) attrs = 0;
	flatbuffers_string_ref_t s = 0;

	ns(Qjob_start(B));
	FB_STR(s, B, jobid == NULL ? "" : jobid);
	ns(Qjob_jobId_add(B, s));
	FB_STR(s, B, destin == NULL ? "" : destin);
	ns(Qjob_destin_add(B, s));
	FB_ATTROPL(attrs, B, aoplp);
	ns(Qjob_attrs_add(B, attrs));

	return ns(Qjob_end(B));
}

ns(JobFile_ref_t)
wire_encode_JobFile(flatcc_builder_t *B, int seq, char *buf, int len, char *jobid, int type)
{
	flatbuffers_string_ref_t s = 0;

	ns(JobFile_start(B));
	ns(JobFile_seq_add(B, seq));
	ns(JobFile_type_add(B, type));
	ns(JobFile_size_add(B, len));
	FB_STR(s, B, jobid);
	ns(JobFile_jobId_add(B, s));
	FB_STRN(s, B, buf, len);
	ns(JobFile_data_add(B, s));

	return ns(JobFile_end(B));
}

ns(JobId_ref_t)
wire_encode_JobId(flatcc_builder_t *B, char *jobid)
{
	flatbuffers_string_ref_t s = 0;

	ns(JobId_start(B));
	FB_STR(s, B, jobid);
	ns(JobId_jobId_add(B, s));

	return ns(JobId_end(B));
}

ns(Manage_ref_t)
wire_encode_Manage(flatcc_builder_t *B, int command, int objtype, char *objname, struct attropl *aoplp)
{
	flatbuffers_string_ref_t s = 0;

	ns(Manage_start(B));
	ns(Manage_cmd_add(B, command));
	ns(Manage_objType_add(B, objtype));
	FB_STR(s, B, objname);
	ns(Manage_objName_add(B, s));
	if (aoplp != NULL) {
		ns(Attribute_vec_ref_t) attrs = 0;
		FB_ATTROPL(attrs, B, aoplp);
		ns(Manage_attrs_add(B, attrs));
	}

	return ns(Manage_end(B));
}

ns(Msg_ref_t)
wire_encode_Message(flatcc_builder_t *B, char *jobid, int fileopt, char *msg)
{
	flatbuffers_string_ref_t s = 0;

	ns(Msg_start(B));
	FB_STR(s, B, jobid);
	ns(Msg_jobId_add(B, s));
	ns(Msg_fileInd_add(B, fileopt));
	FB_STR(s, B, msg);
	ns(Msg_text_add(B, s));

	return ns(Msg_end(B));
}

ns(Move_ref_t)
wire_encode_MoveJob(flatcc_builder_t *B, char *jobid, char *destin)
{
	flatbuffers_string_ref_t s = 0;

	ns(Move_start(B));
	FB_STR(s, B, jobid);
	ns(Move_jobId_add(B, s));
	FB_STR(s, B, destin);
	ns(Move_dest_add(B, s));

	return ns(Move_end(B));
}

ns(Run_ref_t)
wire_encode_Run(flatcc_builder_t *B, char *id, char *where, unsigned long resch)
{
	flatbuffers_string_ref_t s = 0;

	ns(Run_start(B));
	FB_STR(s, B, id);
	ns(Run_jobId_add(B, s));
	FB_STR(s, B, where);
	ns(Run_dest_add(B, s));
	ns(Run_resch_add(B, resch));

	return ns(Run_end(B));
}

ns(Select_ref_t)
wire_encode_Select(flatcc_builder_t *B, struct attropl *aoplp, struct attrl *alp)
{
	ns(Attribute_vec_ref_t) attrs = 0;
	flatbuffers_string_ref_t s = 0;

	ns(Select_start(B));
	FB_ATTROPL(attrs, B, aoplp);
	ns(Select_selAttrs_add(B, attrs));
	if (alp != NULL) {
		FB_ATTRL(attrs, B, alp);
		ns(Select_rtnAttrs_add(B, attrs));
	}

	return ns(Select_end(B));
}

ns(DmnCmd_ref_t)
wire_encode_DmnCmd(flatcc_builder_t *B, int cmd)
{
	flatbuffers_string_ref_t s = 0;

	ns(DmnCmd_start(B));
	ns(DmnCmd_cmd_add(B, cmd));

	return ns(DmnCmd_end(B));
}

ns(Signal_ref_t)
wire_encode_Signal(flatcc_builder_t *B, char *jobid, char *signal)
{
	flatbuffers_string_ref_t s = 0;

	ns(Signal_start(B));
	FB_STR(s, B, jobid);
	ns(Signal_jobId_add(B, s));
	FB_STR(s, B, signal);
	ns(Signal_sigName_add(B, s));

	return ns(Signal_end(B));
}

ns(Stat_ref_t)
wire_encode_Status(flatcc_builder_t *B, char *objid, struct attrl *pattrl)
{
	ns(Attribute_vec_ref_t) attrs = 0;
	flatbuffers_string_ref_t s = 0;

	ns(Stat_start(B));
	FB_STR(s, B, objid);
	ns(Stat_jobIds_add(B, s));
	FB_ATTRL(attrs, B, pattrl);
	ns(Stat_attrs_add(B, attrs));

	return ns(Stat_end(B));
}

ns(Track_ref_t)
wire_encode_TrackJob(flatcc_builder_t *B, char *jobid, int hops, char *location, char state)
{
	flatbuffers_string_ref_t s = 0;

	ns(Track_start(B));
	FB_STR(s, B, jobid);
	ns(Track_jobId_add(B, s));
	FB_STR(s, B, location);
	ns(Track_location_add(B, s));
	ns(Track_hops_add(B, hops));
	ns(Track_state_add(B, state));

	return ns(Track_end(B));
}

ns(RescQuery_ref_t)
wire_encode_RescQuery(flatcc_builder_t *B, char **rlist, int ct, pbs_resource_t rh)
{
	int i = 0;

	ns(RescQuery_start(B));
	ns(RescQuery_handle_add(B, (int)rh));
	flatbuffers_string_vec_start(B);
	for (i = 0; i < ct; i++) {
		flatbuffers_string_ref_t s = 0;
		FB_STR(s, B, *(rlist + i));
		flatbuffers_string_vec_push(B, s);
	}
	ns(RescQuery_queries_add(B, flatbuffers_string_vec_end(B)));

	return ns(RescQuery_end(B));
}

ns(Register_ref_t)
wire_encode_Register(flatcc_builder_t *B, char *owner, char *parent, char *child, int type, int op, int cost)
{
	flatbuffers_string_ref_t s = 0;

	ns(Register_start(B));
	FB_STR(s, B, owner);
	ns(Register_owner_add(B, s));
	FB_STR(s, B, parent);
	ns(Register_parent_add(B, s));
	FB_STR(s, B, child);
	ns(Register_child_add(B, s));
	ns(Register_type_add(B, type));
	ns(Register_op_add(B, op));
	ns(Register_cost_add(B, cost));

	return ns(Register_end(B));
}

ns(CopyFile_ref_t)
wire_encode_CopyFiles(flatcc_builder_t *B, struct rq_cpyfile *pcf)
{
	flatbuffers_string_ref_t s = 0;
	struct rqfpair *ppair = NULL;

	ns(CopyFile_start(B));
	FB_STR(s, B, pcf->rq_jobid);
	ns(CopyFile_jobId_add(B, s));
	FB_STR(s, B, pcf->rq_owner);
	ns(CopyFile_owner_add(B, s));
	FB_STR(s, B, pcf->rq_user);
	ns(CopyFile_user_add(B, s));
	FB_STR(s, B, pcf->rq_group);
	ns(CopyFile_group_add(B, s));
	ns(CopyFile_flags_add(B, pcf->rq_dir));
	ns(FilePair_vec_start(B));
	ppair = (struct rqfpair *)GET_NEXT(pcf->rq_pair);
	while (ppair != NULL) {
		ns(FilePair_start(B));
		FB_STR(s, B, ppair->fp_local);
		ns(FilePair_local_add(B, s));
		FB_STR(s, B, ppair->fp_rmt != NULL ? ppair->fp_rmt : "");
		ns(FilePair_remote_add(B, s));
		ns(FilePair_flag_add(B, ppair->fp_flag));
		ns(FilePair_vec_push(B, ns(FilePair_end(B))));
		ppair = (struct rqfpair *)GET_NEXT(ppair->fp_link);
	}

	return ns(CopyFile_end(B));
}

ns(Cred_ref_t)
wire_encode_Cred(flatcc_builder_t *B, char *jobid, char *credid, int type, char *cred, size_t len, long validity)
{
	flatbuffers_string_ref_t s = 0;

	ns(Cred_start(B));
	ns(Cred_type_add(B, type));
	ns(Cred_size_add(B, len));
	FB_STRN(s, B, cred, len);
	ns(Cred_data_add(B, s));
	if (credid != NULL) {
		FB_STR(s, B, credid);
		ns(Cred_user_add(B, s));
	}
	if (jobid != NULL) {
		FB_STR(s, B, jobid);
		ns(Cred_jobId_add(B, s));
	}
	ns(Cred_validity_add(B, validity));

	return ns(Cred_end(B));
}

ns(Cred_ref_t)
wire_encode_JobCred(flatcc_builder_t *B, int type, char *cred, int len)
{
	return wire_encode_Cred(B, NULL, NULL, type, cred, len, 0);
}

ns(Cred_ref_t)
wire_encode_UserCred(flatcc_builder_t *B, char *user, int type, char *cred, int len)
{
	return wire_encode_Cred(B, NULL, user, type, cred, len, 0);
}

ns(CopyFileCred_ref_t)
wire_encode_CopyFiles_Cred(flatcc_builder_t *B, struct rq_cpyfile_cred *pcf)
{
	flatbuffers_string_ref_t s = 0;
	ns(CopyFileCred_ref_t) files = 0;

	ns(CopyFileCred_start(B));
	files = wire_encode_CopyFiles(B, &(pcf->rq_copyfile));
	if (files == PBSE_FLATCC_ERROR)
		return PBSE_FLATCC_ERROR;
	ns(CopyFileCred_files_add(B, files));
	ns(CopyFileCred_type_add(B, pcf->rq_credtype));
	FB_STRN(s, B, pcf->rq_pcred, pcf->rq_credlen);
	ns(CopyFileCred_cred_add(B, s));

	return ns(CopyFileCred_end(B));
}

ns(UserMigrate_ref_t)
wire_encode_UserMigrate(flatcc_builder_t *B, char *tohost)
{
	flatbuffers_string_ref_t s = 0;

	ns(UserMigrate_start(B));
	FB_STR(s, B, tohost);
	ns(UserMigrate_tohost_add(B, s));

	return ns(UserMigrate_end(B));
}

ns(SchedDefRep_ref_t)
wire_encode_SchedDefRep(flatcc_builder_t *B, int cmd, char *id, int err, char *text)
{
	flatbuffers_string_ref_t s = 0;

	ns(SchedDefRep_start(B));
	ns(SchedDefRep_cmd_add(B, cmd));
	FB_STR(s, B, id);
	ns(SchedDefRep_id_add(B, s));
	ns(SchedDefRep_err_add(B, err));
	if (text != NULL) {
		FB_STR(s, B, text);
		ns(SchedDefRep_text_add(B. s));
	}

	return ns(SchedDefRep_end(B));
}

ns(Spawn_ref_t)
wire_encode_PySpawn(flatcc_builder_t *B, char *jobid, char **argv, char **envp)
{
	flatbuffers_string_ref_t s = 0;
	int i = 0;

	ns(Spawn_start(B));
	FB_STR(s, B, jobid);
	ns(Spawn_jobId_add(B, s));
	flatbuffers_string_vec_start(B);
	i = 0;
	while(argv[i] != NULL) {
		FB_STR(s, B, argv[i]);
		flatbuffers_string_vec_push(B, s);
		i++;
	}
	ns(Spawn_argv_add(B, flatbuffers_string_vec_end(B)));
	flatbuffers_string_vec_start(B);
	i = 0;
	while(envp[i] != NULL) {
		FB_STR(s, B, envp[i]);
		flatbuffers_string_vec_push(B, s);
		i++;
	}
	ns(Spawn_envp_add(B, flatbuffers_string_vec_end(B)));

	return ns(Spawn_end(B));
}

ns(CopyHook_ref_t)
wire_encode_CopyHook(flatcc_builder_t *B, int seq, char *buf, int len, char *hook_filename)
{
	flatbuffers_string_ref_t s = 0;

	ns(CopyHook_start(B));
	ns(CopyHook_seq_add(B, seq));
	ns(CopyHook_size_add(B, len));
	FB_STR(s, B, hook_filename);
	ns(CopyHook_filename_add(B, s));
	FB_STRN(s, B, buf, len);
	ns(CopyHook_data_add(B, s));

	return ns(CopyHook_end(B));
}

ns(CopyHook_ref_t)
wire_encode_DelHook(flatcc_builder_t *B, char *hook_filename)
{
	flatbuffers_string_ref_t s = 0;

	ns(CopyHook_start(B));
	FB_STR(s, B, hook_filename);
	ns(CopyHook_filename_add(B, s));

	return ns(CopyHook_end(B));
}

ns(RelNodes_ref_t)
wire_encode_RelNodes(flatcc_builder_t *B, char *jobid, char *node_list)
{
	flatbuffers_string_ref_t s = 0;

	ns(RelNodes_start(B));
	FB_STR(s, B, jobid);
	ns(RelNodes_jobId_add(B, s));
	FB_STR(s, B, node_list);
	ns(RelNodes_nodes_add(B, s));

	return ns(RelNodes_end(B));
}

ns(Preempt_ref_t)
wire_encode_PreemptJobs(flatcc_builder_t *B, char **preempt_jobs_list)
{
	int i = 0;

	ns(Preempt_start(B));
	ns(PreemptJob_vec_start(B));
	while(preempt_jobs_list[i] != NULL) {
		flatbuffers_string_ref_t s = 0;

		ns(PreemptJob_start(B));
		FB_STR(s, B, preempt_jobs_list[i]);
		ns(PreemptJob_jid_add(B, s));
		ns(PreemptJob_vec_push(B, ns(PreemptJob_end(B))));
		i++;
	}
	ns(Preempt_infos_add(B, ns(PreemptJob_vec_end(B))));

	return ns(Preempt_end(B));
}

ns(Auth_ref_t)
wire_encode_Auth(flatcc_builder_t *B, char *auth_method, char *encrypt_method, int encrypt_mode, int port)
{
	flatbuffers_string_ref_t s = 0;

	ns(Auth_start(B));
	FB_STR(s, B, auth_method);
	ns(Auth_authMethod_add(B, s));
	if (encrypt_method != NULL) {
		FB_STR(s, B, encrypt_method);
		ns(Auth_encryptMethod_add(B, s));
	}
	ns(Auth_encryptMode_add(B, encrypt_mode));
	ns(Auth_port_add(B, port));

	return ns(Auth_end(B));
}

static ns(Resp_ref_t)
__wire_encode_reply_inner(flatcc_builder_t *B, struct batch_reply *reply, char *msgId)
{
	flatbuffers_string_ref_t s = 0;
	int i = 0;

	ns(Resp_start(B));
	ns(Resp_code_add(B, reply->brp_code));
	ns(Resp_auxCode_add(B, reply->brp_auxcode));
	ns(Resp_choice_add(B, reply->brp_choice));

	switch (reply->brp_choice) {
		case BATCH_REPLY_CHOICE_NULL:
			break;

		case BATCH_REPLY_CHOICE_Queue:
		case BATCH_REPLY_CHOICE_RdytoCom:
		case BATCH_REPLY_CHOICE_Commit:

			ns(TextResp_start(B));
			FB_STR(s, B, reply->brp_un.brp_jid);
			ns(TextResp_txt_add(B, s));
			ns(Resp_body_add(B, ns(RespBody_as_TextResp(ns(TextResp_end(B))))));

			break;

		case BATCH_REPLY_CHOICE_Select:
			struct brp_select *psel = reply->brp_un.brp_select;

			ns(SelectResp_start(B));
			flatbuffers_string_vec_start(B);
			while (psel != NULL) {
				FB_STR(s, B, psel->brp_jobid);
				flatbuffers_string_vec_push(B, s);
				psel = psel->brp_next;
			}
			ns(SelectResp_ids_add(B, flatbuffers_string_vec_end(B)));
			ns(Resp_body_add(B, ns(RespBody_as_SelectResp(ns(SelectResp_end(B))))));

			break;

		case BATCH_REPLY_CHOICE_Status:
			struct brp_status *pstat = NULL;

			ns(StatResp_start(B));
			ns(StatRespStat_vec_start(B));
			pstat = (struct brp_status *)GET_NEXT(reply->brp_un.brp_status);
			while (pstat != NULL) {
				ns(Attribute_vec_t) attrs = PBSE_FLATCC_ERROR;

				ns(StatRespStat_start(B));
				ns(StatRespStat_type_add(B, pstat->brp_objtype));
				FB_STR(s, B, pstat->brp_objname);
				ns(StatRespStat_name_add(B, s));
				attrs = wire_encode_svrattrl(B, (svrattrl *)GET_NEXT(pstat->brp_attr));
				if (attrs == PBSE_FLATCC_ERROR)
					return PBSE_FLATCC_ERROR;
				ns(StatRespStat_attrs_add(B, attrs));
				ns(StatRespStat_vec_push(B, ns(StatRespStat_end(B))));
				pstat = (struct brp_status *)GET_NEXT(pstat->brp_stlink);
			}
			ns(StatResp_stats_add(B, ns(StatRespStat_vec_end(B))));
			ns(Resp_body_add(B, ns(RespBody_as_StatResp(ns(StartResp_end(B))))));

			break;

		case BATCH_REPLY_CHOICE_Text:

			ns(TextResp_start(B));
			FB_STRN(s, B, reply->brp_un.brp_txt.brp_str, reply->brp_un.brp_txt.brp_txtlen);
			ns(TextResp_txt_add(B, s));
			ns(Resp_body_add(B, ns(RespBody_as_TextResp(ns(TextResp_end(B))))));

			break;

		case BATCH_REPLY_CHOICE_Locate:

			ns(TextResp_start(B));
			FB_STR(s, B, reply->brp_un.brp_locate);
			ns(TextResp_txt_add(B, s));
			ns(Resp_body_add(B, ns(RespBody_as_TextResp(ns(TextResp_end(B))))));

			break;

		case BATCH_REPLY_CHOICE_RescQuery:

			ns(RescQueryResp_start(B));
			ns(RescQueryRespInfo_vec_start(B));
			for (i = 0; i < reply->brp_un.brp_rescq.brq_number; i++) {
				ns(RescQueryRespInfo_start(B));
				ns(RescQueryRespInfo_avail_add(B, *(reply->brp_un.brp_rescq.brq_avail + i)));
				ns(RescQueryRespInfo_alloc_add(B, *(reply->brp_un.brp_rescq.brq_alloc + i)));
				ns(RescQueryRespInfo_resvd_add(B, *(reply->brp_un.brp_rescq.brq_resvd + i)));
				ns(RescQueryRespInfo_down_add(B, *(reply->brp_un.brp_rescq.brq_down + i)));
				ns(RescQueryRespInfo_vec_push(B, ns(RescQueryRespInfo_end(B))));
			}
			ns(RescQueryResp_infos_add(B, ns(RescQueryRespInfo_vec_end(B))));
			ns(Resp_body_add(B, ns(RespBody_as_RescQueryResp(ns(RescQueryResp_end(B))))));

			break;

		case BATCH_REPLY_CHOICE_PreemptJobs:

			ns(Preempt_start(B));
			ns(PreemptJob_vec_start(B));
			for (i = 0; i < reply->brp_un.brp_preempt_jobs.count; i++) {
				ns(PreemptJob_start(B));
				FB_STR(s, B, reply->brp_un.brp_preempt_jobs.ppj_list[i].job_id);
				ns(PreemptJob_jid_add(B, s));
				FB_STR(s, B, reply->brp_un.brp_preempt_jobs.ppj_list[i].order);
				ns(PreemptJob_order_add(B, s));
				ns(PreemptJob_vec_push(B, ns(PreemptJob_end(B))));
			}
			ns(Preempt_infos_add(B, ns(PreemptJob_vec_end(B))));
			ns(Resp_body_add(B, ns(RespBody_as_Preempt(ns(Preempt_end(B))))));

			break;

		default:
			return PBSE_FLATCC_ERROR;
	}

	return ns(Resp_end(B));
}

int
encode_DIS_reply(int sock, struct batch_reply *reply)
{
	int rc;
	/* first encode "header" consisting of protocol type and version */

	if ((rc = diswui(sock, PBS_BATCH_PROT_TYPE))   ||
		(rc = diswui(sock, PBS_BATCH_PROT_VER)))
			return rc;

	return (encode_DIS_reply_inner(sock, reply));
}

int
encode_DIS_replyTPP(int sock, char *tppcmd_msgid, struct batch_reply *reply)
{
	int rc;
	/* first encode "header" consisting of protocol type and version */

	/* since it TPP connection, write a header */
	if ((rc = is_compose(sock, IS_CMD_REPLY)) != DIS_SUCCESS)
		return rc;

	/* for IS_CMD_REPLY, also send across the tppcmd_msgid, so that
	 * server can match the reply with the request it had sent earlier
	 */
	if ((rc = diswst(sock, tppcmd_msgid)) != DIS_SUCCESS)
		return rc;

	return (encode_DIS_reply_inner(sock, reply));
}
