/*
 * Copyright (C) 1994-2020 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * For a copy of the commercial license terms and conditions,
 * go to: (http://www.pbspro.com/UserArea/agreement.html)
 * or contact the Altair Legal Department.
 *
 * Altair’s dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of PBS Pro and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair’s trademarks, including but not limited to "PBS™",
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
 * trademark licensing policies.
 *
 */

#ifndef PBS_GSS_H
#define PBS_GSS_H

#ifdef __cplusplus
extern "C" {
#endif

#include <pbs_config.h>   /* the master config generated by configure */

#if defined(PBS_SECURITY) && (PBS_SECURITY == KRB5)

#include <gssapi.h>

#define GSS_NT_SERVICE_NAME GSS_C_NT_HOSTBASED_SERVICE

enum PBS_GSS_ROLE {
	PBS_GSS_ROLE_UNKNOWN = 0,
	PBS_GSS_CLIENT, /* must match with TPP_AUTH_CLIENT */
	PBS_GSS_SERVER, /* must match with TPP_AUTH_SERVER */
	PBS_GSS_ROLE_LAST
};

typedef struct {
	gss_ctx_id_t gssctx; /* gss security context */
	int gssctx_established; /* true if gss context has been established */
	int ready; /* true if ready to wrap/unwrap message */
	int confidential; /* wrapping includes encryption */
	enum PBS_GSS_ROLE role; /* value is client or server */
	char *hostname; /* server name */
	char *clientname; /* client name in string */
	gss_buffer_desc client_name; /* client name in gss buffer */
	int init_client_ccache; /* if true the client ccache is attempted to be created from keytab */

	/* TCP only */
	int establishing; /* true if handshake in progress */

	/* TPP only */
	char *cleartext; /* saves cleartext for postsend_handler() */
	int cleartext_len;
} pbs_gss_extra_t;

enum PBS_GSS_ERRORS {
	PBS_GSS_OK = 0,
	PBS_GSS_CONTINUE_NEEDED,
	PBS_GSS_ERR_INTERNAL,
	PBS_GSS_ERR_IMPORT_NAME,
	PBS_GSS_ERR_ACQUIRE_CREDS,
	PBS_GSS_ERR_CONTEXT_INIT,
	PBS_GSS_ERR_CONTEXT_ACCEPT,
	PBS_GSS_ERR_CONTEXT_DELETE,
	PBS_GSS_ERR_CONTEXT_ESTABLISH,
	PBS_GSS_ERR_SENDTOKEN,
	PBS_GSS_ERR_RECVTOKEN,
	PBS_GSS_ERR_NAME_CONVERT,
	PBS_GSS_ERR_INIT_CLIENT_CCACHE,
	PBS_GSS_ERR_WRAPSIZE,
	PBS_GSS_ERR_WRAP,
	PBS_GSS_ERR_UNWRAP,
	PBS_GSS_ERR_CONTEXT_SAVE,
	PBS_GSS_ERR_OID,
	PBS_GSS_ERR_LAST
};

int pbs_gss_can_get_creds();
void* pbs_gss_alloc_gss_extra(int mode);
void pbs_gss_free_gss_extra(void *extra);
int pbs_gss_establish_context(void *extra, void *data_in, int len_in, void **data_out, int *len_out, int *established, char *ebuf, int ebufsz);
int pbs_gss_wrap(void *extra, void *data_in, int len_in, void **data_out, int *len_out, char *ebuf, int ebufsz);
int pbs_gss_unwrap(void *extra, void *data_in, int len_in, void **data_out, int *len_out, char *ebuf, int ebufsz);

void pbs_gss_set_log_handlers(void (*log_gss_status)(const char *msg, OM_uint32 maj_stat, OM_uint32 min_stat),
	void (*logerror)(const char *func_name, const char* msg),
	void (*logdebug)(const char *func_name, const char* msg));

void tpp_gss_logerror(const char *func_name, const char* msg);
void tpp_gss_logdebug(const char *func_name, const char* msg);
void tpp_gss_log_status(const char *msg, OM_uint32 maj_stat, OM_uint32 min_stat);
int tpp_gss_set_extra_host(void *extra, char *hostname);

/* TCP related */
int tcp_gss_client_authenticate(int sock, char *hostname, char *ebuf, int ebufsz);


#endif

#ifdef __cplusplus
}
#endif
#endif /* PBS_GSS_H */
